//
// Created by juperez on 5/26/23.
//

#include "bitmap.h"
#include "ImfHeader.h"
#include "ImfFrameBuffer.h"

#include <ImfInputFile.h>
#include <ImfOutputFile.h>
#include <ImfChannelList.h>
#include <ImfStringAttribute.h>
#include <ImfVersion.h>
#include <ImfIO.h>

#define STB_IMAGE_WRITE_IMPLEMENTATION
#include <nanogui/ext/nanovg/example/stb_image_write.h>

LUMINA_NAMESPACE_BEGIN

Bitmap::Bitmap(const std::string& filename) {
    Imf::InputFile file(filename.c_str());
    const Imf::Header& header = file.header();
    const Imf::ChannelList& channels = header.channels();

    Imath::Box2i window = file.header().dataWindow();
    resize(window.max.y - window.min.y + 1, window.max.x - window.min.x + 1);

    std::cout << "Reading a " << cols() << "x" << rows() << " OpenEXR file from " << filename << "\n";

    const char* ch_r = nullptr, *ch_g = nullptr, *ch_b = nullptr;
    for (Imf::ChannelList::ConstIterator it = channels.begin(); it != channels.end(); ++it) {
        std::string name = toLower(it.name());

        if (it.channel().xSampling != 1 || it.channel().ySampling != 1) {
            /* Sub-sampled layers are not supported */
            continue;
        }

        if (!ch_r && (name == "r" || name == "red" ||
                      endsWith(name, ".r") || endsWith(name, ".red"))) {
            ch_r = it.name();
        } else if (!ch_g && (name == "g" || name == "green" ||
                             endsWith(name, ".g") || endsWith(name, ".green"))) {
            ch_g = it.name();
        } else if (!ch_b && (name == "b" || name == "blue" ||
                             endsWith(name, ".b") || endsWith(name, ".blue"))) {
            ch_b = it.name();
        }
    }

    if (!ch_r || !ch_g || !ch_b)
        throw LuminaException("This is not a standard RGB OpenEXR file!");

    size_t compStride = sizeof(float),
            pixelStride = 3 * compStride,
            rowStride = pixelStride * cols();

    char *ptr = reinterpret_cast<char *>(data());

    Imf::FrameBuffer frameBuffer;
    frameBuffer.insert(ch_r, Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
    frameBuffer.insert(ch_g, Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
    frameBuffer.insert(ch_b, Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride));
    file.setFrameBuffer(frameBuffer);
    file.readPixels(window.min.y, window.max.y);
}

void Bitmap::saveEXR(const std::string& filename) {
    std::cout << "Writing a " << cols() << "x" << rows()
         << " OpenEXR file to \"" << filename << "\"" << "\n";

    std::string path = filename + ".exr";

    Imf::Header header((int) cols(), (int) rows());
    header.insert("comments", Imf::StringAttribute("Generated by Lumina"));

    Imf::ChannelList& channels = header.channels();
    channels.insert("R", Imf::Channel(Imf::FLOAT));
    channels.insert("G", Imf::Channel(Imf::FLOAT));
    channels.insert("B", Imf::Channel(Imf::FLOAT));

    Imf::FrameBuffer frameBuffer;
    size_t compStride = sizeof(float),
            pixelStride = 3 * compStride,
            rowStride = pixelStride * cols();

    char* ptr = reinterpret_cast<char *>(data());
    frameBuffer.insert("R", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
    frameBuffer.insert("G", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride)); ptr += compStride;
    frameBuffer.insert("B", Imf::Slice(Imf::FLOAT, ptr, pixelStride, rowStride));

    Imf::OutputFile file(path.c_str(), header);
    file.setFrameBuffer(frameBuffer);
    file.writePixels((int) rows());
}

void Bitmap::savePNG(const std::string& filename) {
    std::cout << "Writing a " << cols() << "x" << rows()
              << " PNG file to \"" << filename << "\"" << "\n";

    std::string path = filename + ".png";

    uint8_t* rgb8 = new uint8_t[3 * cols() * rows()];
    uint8_t* dst = rgb8;

    for (int i = 0; i < rows(); i++) {
        for (int j = 0; j < cols(); j++) {
            Color3f tonemapped = coeffRef(i, j).toSRGB();
            dst[0] = (uint8_t) std::clamp(255.0f * tonemapped[0], 0.0f, 255.0f);
            dst[1] = (uint8_t) std::clamp(255.0f * tonemapped[1], 0.0f, 255.0f);
            dst[2] = (uint8_t) std::clamp(255.0f * tonemapped[2], 0.0f, 255.0f);
            dst += 3;
        }
    }

    int ret = stbi_write_png(path.c_str(), (int) cols(), (int) rows(), 3, rgb8, 3 * (int) cols());
    if (ret == 0) {
        std::cout << "Bitmap::savePNG(): Could not save PNG file \"" << path << "%s\" \n";
    }

    delete[] rgb8;
}

LUMINA_NAMESPACE_END